# CRCU Analytics MCP - Enhanced Business Rules Configuration
# ==========================================================
# Based on comprehensive validation report - Critical corrections applied
# Enhanced with database structure and entity relationships

# Database Connection Configuration
databases:
  arcusym000:
    name: "ARCUSYM000"
    description: "Core Banking System - Symitar"
    primary_tables:
      - MEMBERREC
      - ACCOUNT
      - SAVINGS
      - LOAN
      - NAME
      - CARD
  temenos:
    name: "TEMENOS"  
    description: "Collections and Account Management System"
    primary_tables:
      - tblAccount
      - tblAccountInfo
      - tblCustomer
      - tblPromise
      - tblPaymentHistory

# Core Entity Relationships
entity_relationships:
  
  # Member-Account Relationships
  member_account:
    description: "Defines the relationship between members and their accounts"
    source_table: ARCUSYM000.dbo.ACCOUNT
    target_table: ARCUSYM000.dbo.MEMBERREC
    relationship_type: "many_to_one"
    join_rules:
      - type: "member_lookup"
        logic: |
          SELECT DISTINCT 
            a.ACCOUNTNUMBER,
            n.PARENTACCOUNT,
            n.MEMBERNUMBER,
            m.MEMBERID,
            n.TYPE as NAME_TYPE,
            n.ORDINAL
          FROM ARCUSYM000.dbo.ACCOUNT a
          INNER JOIN ARCUSYM000.dbo.NAME n 
            ON a.ACCOUNTNUMBER = n.PARENTACCOUNT
          LEFT JOIN ARCUSYM000.dbo.MEMBERREC m 
            ON n.MEMBERNUMBER = m.MEMBERNUMBER
          WHERE n.TYPE IN (0, 1, 2) -- Primary, Joint, Beneficiary
            AND a.etlIsCurrent = 1
            AND a.ProcessDate = {process_date}
  
  # Account-Savings Relationships
  account_savings:
    description: "Links account records to savings/share details"
    source_table: ARCUSYM000.dbo.SAVINGS
    target_table: ARCUSYM000.dbo.ACCOUNT
    relationship_type: "one_to_one"
    join_rules:
      - type: "direct"
        source_key: "PARENTACCOUNT,ID"
        target_key: "ACCOUNTNUMBER"
        filter: "CLOSEDATE IS NULL"
  
  # Account-Loan Relationships  
  account_loans:
    description: "Links account records to loan details"
    source_table: ARCUSYM000.dbo.LOAN
    target_table: ARCUSYM000.dbo.ACCOUNT
    relationship_type: "one_to_one"
    join_rules:
      - type: "direct"
        source_key: "PARENTACCOUNT,ID"
        target_key: "ACCOUNTNUMBER"
        filter: "CLOSEDATE IS NULL"
  
  # Card Relationships
  card_relationships:
    description: "Links cards to accounts and members"
    source_table: ARCUSYM000.dbo.CARD
    target_table: ARCUSYM000.dbo.ACCOUNT
    relationship_type: "many_to_one"
    join_rules:
      - type: "composite"
        logic: |
          SELECT 
            c.CARDNUMBER,
            c.PARENTACCOUNT,
            cn.MEMBERNUMBER,
            c.STATUS as CARD_STATUS,
            c.TYPE as CARD_TYPE
          FROM ARCUSYM000.dbo.CARD c
          LEFT JOIN ARCUSYM000.dbo.CARDNAME cn
            ON c.CARDNUMBER = cn.PARENTCARD
          WHERE c.STATUS IN (1, 2, 3) -- Active, Blocked, Restricted
  
  # Cross-System Account Mapping
  cross_system_mapping:
    description: "Maps accounts between ARCUSYM000 and TEMENOS"
    source_table: TEMENOS.dbo.tblAccount
    target_table: ARCUSYM000.dbo.ACCOUNT
    relationship_type: "one_to_one"
    join_rules:
      - type: "identifier_match"
        source_key: "AccountIdentifier"
        target_key: "ACCOUNTNUMBER"
        transformation: "TRIM(REPLACE(AccountIdentifier, '-', ''))"

business_rules:
  # CRITICAL: ProcessDate Filter Requirements - CORRECTED
  process_date_requirements:
    mandatory: true
    description: "Database contains daily historical snapshots - MUST filter by ProcessDate"
    format: "YYYYMMDD string format (yesterday's date)"
    correct_filter: "ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
    incorrect_filter: "ProcessDate = (SELECT MAX(ProcessDate) FROM {table})"
    validation_rule: "All queries MUST include ProcessDate filter to avoid historical aggregation"
    impact: "Without ProcessDate filter, queries aggregate ALL historical daily snapshots"
    note: "ProcessDate is yesterday's date in YYYYMMDD format, not MAX(ProcessDate)"
    
  # Expected Data Ranges - For Validation
  expected_ranges:
    active_members:
      min: 50000
      max: 65000
      description: "Expected active member count range"
    total_deposits:
      min: 500000000  # $500M
      max: 900000000  # $900M
      description: "Expected total deposit range"
    total_loans:
      min: 200000000  # $200M
      max: 500000000  # $500M
      description: "Expected total loan range"
    loan_accounts:
      min: 30000
      max: 40000
      description: "Expected active loan account count"

  # CORRECTED: Active Record Indicators - DEFINITIVE (from production query)
  active_record_indicators:
    LOAN:
      field: "CloseDate"
      active_condition: "(CloseDate IS NULL OR CloseDate = '1900-01-01')"
      description: "NULL OR '1900-01-01' indicates active loan"
    SAVINGS:
      field: "CloseDate" 
      active_condition: "(CloseDate IS NULL OR CloseDate = '1900-01-01')"
      description: "NULL OR '1900-01-01' indicates active savings account"
    ACCOUNT:
      field: "CloseDate"
      active_condition: "(CloseDate IS NULL OR CloseDate = '1900-01-01')"
      description: "NULL OR '1900-01-01' indicates active account"
    CARD:
      field: "STATUS"
      active_values: [1, 2, 3]  # TO BE VALIDATED
      description: "Status 1,2,3 indicates active card"
  
  # CORRECTED: Charge-off Indicators - DEFINITIVE (from production query)
  charged_off_indicators:
    LOAN:
      field: "ChargeOffDate"
      active_condition: "(ChargeOffDate IS NULL OR ChargeOffDate = '1900-01-01')"
      description: "NULL OR '1900-01-01' indicates not charged off"
    SAVINGS:
      field: "ChargeOffDate"
      active_condition: "(ChargeOffDate IS NULL OR ChargeOffDate = '1900-01-01')"
      description: "NULL OR '1900-01-01' indicates not charged off"
  
  # CORRECTED: Data Type Requirements
  data_type_requirements:
    account_comparisons: "CAST(ACCOUNTNUMBER AS BIGINT)"
    parent_comparisons: "CAST(PARENTACCOUNT AS BIGINT)"
    reason: "Account numbers exceed INT range, require BIGINT casting"
  
  # CORRECTED: Field Name Mappings
  field_corrections:
    LOANTRANSACTION:
      documented_field: "ID"
      actual_field: "PARENTID"
      impact: "Join operations must use PARENTID"
    SAVINGSTRANSACTION:
      documented_field: "ID" 
      actual_field: "PARENTID"
      impact: "Join operations must use PARENTID"
    NAME:
      actual_field: "MBRSTATUS"  # NOT MemberStatus
      description: "Member status field name correction"
    NAME_JOIN_DATE:
      actual_field: "MBRCREATEDATE"  # NOT JoinDate
      description: "Member creation date field correction"

  # DEFINITIVE: Active Member Criteria (from production Power BI query)
  active_member_definition:
    description: "Definitive member criteria from production Power BI query - EXACT IMPLEMENTATION"
    
    # Core Process Date Logic - CRITICAL
    process_date_logic:
      formula: "FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
      description: "Yesterday's date in YYYYMMDD format - MUST be used consistently"
      note: "This is the definitive process date calculation used across all tables"
    
    # Name Table Criteria
    name_criteria:
      primary_name: "n.TYPE = 0"
      valid_ssn: "n.SSN IS NOT NULL AND n.SSN <> ''"
      process_date: "n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
      join_condition: "n.PARENTACCOUNT = a.ACCOUNTNUMBER"
    
    # Account Table Criteria  
    account_criteria:
      process_date: "a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
      allowed_types: [0, 1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 15, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
      active_condition: "(a.CloseDate IS NULL OR a.CloseDate = '1900-01-01')"
    
    # Product Requirements - Must have EITHER active loans OR active savings
    product_requirements:
      description: "Must have either active loans OR active savings (not both required)"
      logic_operator: "OR"
      
      loan_requirement:
        table: "Loan"
        join_condition: "l.PARENTACCOUNT = a.AccountNumber"
        process_date: "l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
        active_conditions:
          - "(l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')"
          - "(l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')"
        exists_query: |
          EXISTS (
              SELECT 1 FROM Loan l 
              WHERE l.PARENTACCOUNT = a.AccountNumber 
                  AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                  AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
                  AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
          )
      
      savings_requirement:
        table: "SAVINGS"
        join_condition: "s.PARENTACCOUNT = a.AccountNumber"
        process_date: "s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
        active_conditions:
          - "(s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')"
          - "(s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')"
        exists_query: |
          EXISTS (
              SELECT 1 FROM SAVINGS s 
              WHERE s.PARENTACCOUNT = a.AccountNumber 
                  AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                  AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
                  AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
          )
      
      combined_requirement: |
        (
            EXISTS (
                SELECT 1 FROM Loan l 
                WHERE l.PARENTACCOUNT = a.AccountNumber 
                    AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
                    AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
            )
            OR 
            EXISTS (
                SELECT 1 FROM SAVINGS s 
                WHERE s.PARENTACCOUNT = a.AccountNumber 
                    AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
                    AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
            )
        )
    
    # Uniqueness Logic - One record per SSN
    uniqueness_logic:
      method: "One record per SSN, earliest account by OpenDate"
      partition_by: "n.SSN"
      order_by: "a.OpenDate ASC"
      window_functions:
        account_number: "FIRST_VALUE(a.AccountNumber) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC)"
        account_type: "FIRST_VALUE(a.TYPE) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC)"
        branch: "FIRST_VALUE(a.Branch) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC)"
      final_filter: "ROW_NUMBER() OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC) = 1"
    
    # Complete Query Structure
    complete_query_structure: |
      SELECT 
          FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd') as ProcessDate,
          ActiveMembers.AccountType,
          [Account Type Descriptions],
          ActiveMembers.LAST as MemberName,
          ActiveMembers.AccountNumber,
          ActiveMembers.SSN,
          ActiveMembers.Branch,
          [Formatted Account Type],
          1 as MemberCount
      FROM (
          SELECT DISTINCT 
              n.SSN,
              n.LAST,
              n.MemberNumber,
              FIRST_VALUE(a.AccountNumber) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC) as AccountNumber,
              FIRST_VALUE(a.TYPE) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC) as AccountType,
              FIRST_VALUE(a.Branch) OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC) as Branch,
              ROW_NUMBER() OVER (PARTITION BY n.SSN ORDER BY a.OpenDate ASC) as rn
          FROM Name n
          INNER JOIN Account a ON n.PARENTACCOUNT = a.ACCOUNTNUMBER
          WHERE n.TYPE = 0
              AND n.SSN IS NOT NULL 
              AND n.SSN <> ''
              AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
              AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
              AND a.TYPE IN (0, 1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 15, 
                               87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
              AND (a.CloseDate IS NULL OR a.CloseDate = '1900-01-01')
              AND (
                  EXISTS (
                      SELECT 1 FROM Loan l 
                      WHERE l.PARENTACCOUNT = a.AccountNumber 
                          AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                          AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
                          AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
                  )
                  OR 
                  EXISTS (
                      SELECT 1 FROM SAVINGS s 
                      WHERE s.PARENTACCOUNT = a.AccountNumber 
                          AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                          AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
                          AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
                  )
              )
      ) ActiveMembers
      WHERE ActiveMembers.rn = 1
    
    account_type_mappings:
      0: "General Membership"
      1: "Share Draft"  
      2: "Money Market"
      5: "Certificate"
      6: "IRA"
      8: "Minor"
      9: "Representative Payee"
      10: "Club"
      11: "TUTMA"
      12: "Benefit"
      13: "Indirect"
      15: "Guardianship"
      87: "Professional Association"
      88: "Sole Proprietorship-Individual"
      89: "Trust"
      90: "C Corporation"
      91: "S Corporation"
      92: "Sole Proprietorship-Non-Individual"
      93: "Limited Liability Co (LLC)"
      94: "General Partnership"
      95: "Limited Partnership"
      96: "Limited Liability Partnership"
      97: "Non Profit Org/Assoc/Club"
      98: "Non Profit Corporation"
      99: "Estate"

# Business Validation Rules (Enhanced)
validation_rules:

  # Member Status Validation
  member_status:
    description: "Validates member status and eligibility"
    applies_to: "MEMBERREC"
    rules:
      - name: "active_member"
        condition: "MBRSTATUS IN (0, 1, 2)"
        description: "Member is active or restricted"
      - name: "deceased_member"
        condition: "DEATHDATE IS NOT NULL"
        description: "Member is deceased"
      - name: "disconnected_member"
        condition: "MBRDISCONNECTDATE IS NOT NULL"
        description: "Member has been disconnected"
  
  # Account Status Validation
  account_status:
    description: "Validates account status and restrictions"
    applies_to: "ACCOUNT"
    rules:
      - name: "open_account"
        condition: "CLOSEDATE IS NULL"
        description: "Account is open"
      - name: "restricted_account"
        condition: "RESTRICTACCESS > 0"
        description: "Account has access restrictions"
      - name: "frozen_account"
        condition: "FROZENMODE > 0"
        description: "Account is frozen"
  
  # Delinquency Rules
  delinquency:
    description: "Rules for identifying delinquent accounts"
    applies_to: "LOAN"
    rules:
      - name: "current"
        condition: "PAYMENTDUE = 0 OR DATEDIFF(DAY, LASTPAYMENTDATE, GETDATE()) <= 30"
      - name: "delinquent_30"
        condition: "DATEDIFF(DAY, LASTPAYMENTDATE, GETDATE()) BETWEEN 31 AND 60"
      - name: "delinquent_60"  
        condition: "DATEDIFF(DAY, LASTPAYMENTDATE, GETDATE()) BETWEEN 61 AND 90"
      - name: "delinquent_90_plus"
        condition: "DATEDIFF(DAY, LASTPAYMENTDATE, GETDATE()) > 90"
      - name: "charged_off"
        condition: "CHARGEOFFDATE IS NOT NULL"

# Aggregate Calculations
aggregate_calculations:

  member_total_balances:
    description: "Calculate total balances across all accounts for a member"
    logic: |
      WITH MemberAccounts AS (
        SELECT 
          n.MEMBERNUMBER,
          a.ACCOUNTNUMBER,
          a.TYPE as ACCOUNT_TYPE
        FROM ARCUSYM000.dbo.NAME n
        INNER JOIN ARCUSYM000.dbo.ACCOUNT a 
          ON n.PARENTACCOUNT = a.ACCOUNTNUMBER
        WHERE n.TYPE = 0 -- Primary owner
          AND a.CLOSEDATE IS NULL
      )
      SELECT 
        ma.MEMBERNUMBER,
        SUM(CASE WHEN s.ID IS NOT NULL THEN s.BALANCE ELSE 0 END) as TOTAL_SAVINGS,
        SUM(CASE WHEN l.ID IS NOT NULL THEN l.BALANCE ELSE 0 END) as TOTAL_LOANS,
        COUNT(DISTINCT s.ID) as SAVINGS_COUNT,
        COUNT(DISTINCT l.ID) as LOAN_COUNT
      FROM MemberAccounts ma
      LEFT JOIN ARCUSYM000.dbo.SAVINGS s 
        ON ma.ACCOUNTNUMBER = CONCAT(s.PARENTACCOUNT, '-', s.ID)
      LEFT JOIN ARCUSYM000.dbo.LOAN l 
        ON ma.ACCOUNTNUMBER = CONCAT(l.PARENTACCOUNT, '-', l.ID)
      GROUP BY ma.MEMBERNUMBER

  account_relationship_summary:
    description: "Summarize all relationships for an account"
    logic: |
      SELECT 
        a.ACCOUNTNUMBER,
        COUNT(DISTINCT n.MEMBERNUMBER) as MEMBER_COUNT,
        STRING_AGG(
          CASE n.TYPE 
            WHEN 0 THEN 'Primary'
            WHEN 1 THEN 'Joint'
            WHEN 2 THEN 'Beneficiary'
            ELSE 'Other'
          END, ', '
        ) as RELATIONSHIP_TYPES,
        MAX(CASE WHEN n.TYPE = 0 THEN n.MEMBERNUMBER END) as PRIMARY_MEMBER
      FROM ARCUSYM000.dbo.ACCOUNT a
      INNER JOIN ARCUSYM000.dbo.NAME n ON a.ACCOUNTNUMBER = n.PARENTACCOUNT
      WHERE a.CLOSEDATE IS NULL
      GROUP BY a.ACCOUNTNUMBER

  collections_status:
    description: "Aggregate collections status from TEMENOS"
    logic: |
      SELECT 
        ta.AccountIdentifier,
        ta.DelinquentFlag,
        ta.CurrentQueueID,
        COUNT(DISTINCT p.PromiseID) as ACTIVE_PROMISES,
        MAX(p.PromiseDate) as LAST_PROMISE_DATE,
        SUM(CASE WHEN p.PromiseStatusID = 3 THEN 1 ELSE 0 END) as BROKEN_PROMISES
      FROM TEMENOS.dbo.tblAccount ta
      LEFT JOIN TEMENOS.dbo.tblPromise p 
        ON ta.AccountID = p.AccountID 
        AND p.PromiseStatusID IN (1, 2) -- Open or Pending
      WHERE ta.ActiveFlag = 1
      GROUP BY ta.AccountIdentifier, ta.DelinquentFlag, ta.CurrentQueueID

# Validated Query Patterns - WITH MANDATORY PROCESSDATE FILTER
validated_queries:
  # CRITICAL: All queries MUST include ProcessDate filter
  get_current_process_date: >
    SELECT MAX(ProcessDate) as CurrentProcessDate FROM {table}
  
  active_members_with_process_date: >
    WITH CurrentSnapshot AS (
        SELECT MAX(ProcessDate) as CurrentDate FROM NAME
    )
    SELECT n.* FROM NAME n
    CROSS JOIN CurrentSnapshot cs
    WHERE n.ProcessDate = cs.CurrentDate 
    AND n.MBRSTATUS = 0
    AND n.TYPE = 0
    AND CAST(n.PARENTACCOUNT AS BIGINT) > 100
  
  active_loans_with_process_date: >
    WITH CurrentSnapshot AS (
        SELECT MAX(ProcessDate) as CurrentDate FROM LOAN
    )
    SELECT l.* FROM LOAN l 
    CROSS JOIN CurrentSnapshot cs
    WHERE l.ProcessDate = cs.CurrentDate
    AND l.CLOSEDATE IS NULL 
    AND l.CHARGEOFFDATE IS NULL 
    AND CAST(l.PARENTACCOUNT AS BIGINT) > 100
  
  active_savings_with_process_date: >
    WITH CurrentSnapshot AS (
        SELECT MAX(ProcessDate) as CurrentDate FROM SAVINGS
    )
    SELECT s.* FROM SAVINGS s
    CROSS JOIN CurrentSnapshot cs
    WHERE s.ProcessDate = cs.CurrentDate
    AND s.CLOSEDATE IS NULL 
    AND CAST(s.PARENTACCOUNT AS BIGINT) > 100

  # Template for all queries
  query_template_with_process_date: >
    WITH CurrentSnapshot AS (
        SELECT MAX(ProcessDate) as CurrentDate FROM {primary_table}
    )
    SELECT {columns}
    FROM {primary_table} pt
    CROSS JOIN CurrentSnapshot cs
    WHERE pt.ProcessDate = cs.CurrentDate
    AND {additional_conditions}
  
  member_profitability_base: >
    SELECT 
      a.ACCOUNTNUMBER,
      n.FIRST + ' ' + n.LAST as MemberName,
      SUM(ISNULL(l.INTERESTYTD, 0) + ISNULL(l.INTERESTLASTYEAR, 0)) as InterestIncome,
      SUM(ISNULL(s.FEEYTD, 0) + ISNULL(s.FEESLASTYEAR, 0)) as AccountFees
    FROM ACCOUNT a
    INNER JOIN NAME n ON a.ACCOUNTNUMBER = n.PARENTACCOUNT AND n.TYPE = 0
    LEFT JOIN LOAN l ON a.ACCOUNTNUMBER = l.PARENTACCOUNT AND l.CLOSEDATE IS NULL AND l.CHARGEOFFDATE IS NULL
    LEFT JOIN SAVINGS s ON a.ACCOUNTNUMBER = s.PARENTACCOUNT AND s.CLOSEDATE IS NULL
    WHERE a.CLOSEDATE IS NULL AND CAST(a.ACCOUNTNUMBER AS BIGINT) > 100
    GROUP BY a.ACCOUNTNUMBER, n.FIRST, n.LAST

# Transaction Code Mappings (TO BE VALIDATED WITH ACTUAL DATA)
transaction_codes:
  LOANTRANSACTION:
    interest_income:
      codes: [501, 502, 503, 510, 520]
      description: "Interest payment transactions"
      validation_status: "PENDING"
    
    fees_non_punitive:
      codes: [301, 302, 303]
      description: "Service and maintenance fees"
      validation_status: "PENDING"
    
    fees_punitive:
      codes: [700, 701, 702, 710, 720]
      description: "NSF, overdraft, late fees"
      validation_status: "PENDING"
  
  SAVINGSTRANSACTION:
    fees_non_punitive:
      codes: [601, 602, 603, 610, 620, 630]
      description: "Account service fees"
      validation_status: "PENDING"
    
    fees_punitive:
      codes: [700, 701, 702, 703, 710, 711, 712, 720]
      description: "Overdraft and NSF fees"
      validation_status: "PENDING"

# Performance Settings
performance_settings:
  max_cte_depth: 5
  recommended_batch_size: 1000
  timeout_seconds: 30
  use_date_filters: true
  default_date_range_months: 12

# Data Quality Checks
data_quality_rules:
  required_validations:
    - "process_date_filter_validation"  # NEW: Critical validation
    - "active_record_validation"
    - "chargeoff_validation"
    - "transaction_schema_validation"
    - "account_number_datatype_check"
    - "magnitude_validation"  # NEW: Check for realistic numbers
  
  magnitude_validations:
    active_members:
      min_expected: 50000
      max_expected: 65000
      error_if_outside: true
      message: "Member count outside expected range - check ProcessDate filter"
    
    total_deposits:
      min_expected: 500000000
      max_expected: 900000000
      error_if_outside: true
      message: "Deposit total outside expected range - check ProcessDate filter"
    
    total_loans:
      min_expected: 200000000
      max_expected: 500000000
      error_if_outside: true
      message: "Loan total outside expected range - check ProcessDate filter"
      
    loan_count:
      min_expected: 30000
      max_expected: 40000
      error_if_outside: true
      message: "Loan count outside expected range - check ProcessDate filter"
  
  warning_thresholds:
    active_member_variance_percent: 10
    profitability_zero_results_percent: 5
    missing_data_percent: 15
  
  error_conditions:
    - "No ProcessDate filter detected in query"  # NEW
    - "No active members found"
    - "All profitability calculations return zero"
    - "Data type casting failures"
    - "Results exceed magnitude thresholds"  # NEW

# PII Protection Settings
pii_protection:
  high_sensitivity_fields:
    - "SSN"
    - "FIRST"
    - "LAST"
    - "BIRTHDATE"
    - "ADDRESS"
    - "PHONE"
    - "EMAIL"
  
  default_protection_actions:
    - "Mask SSN in results"
    - "Use account IDs instead of names when possible"
    - "Apply aggregation where feasible"
    - "Log all PII access"

# MCP-COMPATIBLE QUERY TEMPLATES - Simplified for Direct Use
# ========================================================
# These templates avoid complex window functions and work within MCP restrictions

mcp_compatible_queries:
  description: "SELECT-only queries compatible with MCP restrictions - no procedural code"
  
  # Simple Active Member Count - Core Logic
  simple_active_member_count: |
    SELECT 
        COUNT(DISTINCT n.SSN) as ActiveMemberCount,
        COUNT(DISTINCT a.ACCOUNTNUMBER) as TotalActiveAccounts,
        FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd') as ProcessDate,
        'Definitive Active Member Logic Applied' as QueryType
    FROM Name n
    INNER JOIN Account a ON n.PARENTACCOUNT = a.ACCOUNTNUMBER
    WHERE n.TYPE = 0
        AND n.SSN IS NOT NULL 
        AND n.SSN <> ''
        AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
        AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
        AND a.TYPE IN (0, 1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 15, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
        AND (a.CloseDate IS NULL OR a.CloseDate = '1900-01-01')
        AND (
            EXISTS (
                SELECT 1 FROM Loan l 
                WHERE l.PARENTACCOUNT = a.ACCOUNTNUMBER 
                    AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
                    AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
            )
            OR 
            EXISTS (
                SELECT 1 FROM SAVINGS s 
                WHERE s.PARENTACCOUNT = a.ACCOUNTNUMBER 
                    AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
                    AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
            )
        )

  # Member Breakdown by Account Type - Simplified
  member_breakdown_by_account_type: |
    SELECT 
        a.TYPE as AccountType,
        CASE a.TYPE
            WHEN 0 THEN 'General Membership'
            WHEN 1 THEN 'Share Draft'
            WHEN 2 THEN 'Money Market'
            WHEN 5 THEN 'Certificate'
            WHEN 6 THEN 'IRA'
            WHEN 8 THEN 'Minor'
            WHEN 9 THEN 'Representative Payee'
            WHEN 10 THEN 'Club'
            WHEN 11 THEN 'TUTMA'
            WHEN 12 THEN 'Benefit'
            WHEN 13 THEN 'Indirect'
            WHEN 15 THEN 'Guardianship'
            WHEN 87 THEN 'Professional Association'
            WHEN 88 THEN 'Sole Proprietorship-Individual'
            WHEN 89 THEN 'Trust'
            WHEN 90 THEN 'C Corporation'
            WHEN 91 THEN 'S Corporation'
            WHEN 92 THEN 'Sole Proprietorship-Non-Individual'
            WHEN 93 THEN 'Limited Liability Co (LLC)'
            WHEN 94 THEN 'General Partnership'
            WHEN 95 THEN 'Limited Partnership'
            WHEN 96 THEN 'Limited Liability Partnership'
            WHEN 97 THEN 'Non Profit Org/Assoc/Club'
            WHEN 98 THEN 'Non Profit Corporation'
            WHEN 99 THEN 'Estate'
            ELSE 'Unknown'
        END as AccountTypeDescription,
        COUNT(DISTINCT n.SSN) as MemberCount,
        COUNT(DISTINCT a.ACCOUNTNUMBER) as AccountCount,
        FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd') as ProcessDate
    FROM Name n
    INNER JOIN Account a ON n.PARENTACCOUNT = a.ACCOUNTNUMBER
    WHERE n.TYPE = 0
        AND n.SSN IS NOT NULL 
        AND n.SSN <> ''
        AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
        AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
        AND a.TYPE IN (0, 1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 15, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
        AND (a.CloseDate IS NULL OR a.CloseDate = '1900-01-01')
        AND (
            EXISTS (
                SELECT 1 FROM Loan l 
                WHERE l.PARENTACCOUNT = a.ACCOUNTNUMBER 
                    AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
                    AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
            )
            OR 
            EXISTS (
                SELECT 1 FROM SAVINGS s 
                WHERE s.PARENTACCOUNT = a.ACCOUNTNUMBER 
                    AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
                    AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
                    AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
            )
        )
    GROUP BY a.TYPE
    ORDER BY MemberCount DESC

  # Financial Summary - Active Products Only
  financial_summary_active_products: |
    SELECT 
        SUM(CAST(ISNULL(s.BALANCE, 0) as FLOAT)) as total_savings,
        SUM(CAST(ISNULL(l.BALANCE, 0) as FLOAT)) as total_loans,
        COUNT(DISTINCT s.PARENTACCOUNT) as savings_accounts,
        COUNT(DISTINCT l.PARENTACCOUNT) as loan_accounts,
        FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd') as process_date
    FROM (
        SELECT PARENTACCOUNT, BALANCE 
        FROM SAVINGS 
        WHERE ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
            AND (CLOSEDATE IS NULL OR CLOSEDATE = '1900-01-01')
            AND CAST(PARENTACCOUNT AS BIGINT) > 100
    ) s
    FULL OUTER JOIN (
        SELECT PARENTACCOUNT, BALANCE 
        FROM LOAN 
        WHERE ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
            AND (CLOSEDATE IS NULL OR CLOSEDATE = '1900-01-01')
            AND (CHARGEOFFDATE IS NULL OR CHARGEOFFDATE = '1900-01-01')
            AND CAST(PARENTACCOUNT AS BIGINT) > 100
    ) l ON s.PARENTACCOUNT = l.PARENTACCOUNT

# DEFINITIVE BUSINESS LOGIC - Key Components
definitive_logic_components:
  description: "Core components extracted from specialized functions for reuse"
  
  # Process Date Formula - Universal
  process_date_calculation:
    formula: "FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
    description: "Yesterday's date in YYYYMMDD format - use consistently across all tables"
    sql_usage: "ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
  
  # Core Table Join - Primary Relationship  
  primary_table_join:
    relationship: "Name n INNER JOIN Account a ON n.PARENTACCOUNT = a.ACCOUNTNUMBER"
    description: "Primary relationship between members and accounts"
    note: "Name table is the bridge - contains member info linked to accounts"
  
  # Active Member Criteria - Essential Filters
  active_member_filters:
    primary_member: "n.TYPE = 0"
    valid_ssn: "n.SSN IS NOT NULL AND n.SSN <> ''"
    current_name_record: "n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
    current_account_record: "a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
    valid_account_types: "a.TYPE IN (0, 1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 15, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)"
    account_not_closed: "(a.CloseDate IS NULL OR a.CloseDate = '1900-01-01')"
  
  # Product Requirements - Must Have Active Products
  product_existence_requirements:
    description: "Member must have EITHER active loans OR active savings (not both required)"
    loan_exists_clause: |
      EXISTS (
          SELECT 1 FROM Loan l 
          WHERE l.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
              AND (l.ChargeOffDate IS NULL OR l.ChargeOffDate = '1900-01-01')
              AND (l.CloseDate IS NULL OR l.CloseDate = '1900-01-01')
      )
    savings_exists_clause: |
      EXISTS (
          SELECT 1 FROM SAVINGS s 
          WHERE s.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
              AND (s.ChargeOffDate IS NULL OR s.ChargeOffDate = '1900-01-01')
              AND (s.CloseDate IS NULL OR s.CloseDate = '1900-01-01')
      )
    combined_requirement: "({loan_exists_clause}) OR ({savings_exists_clause})"

# Usage Instructions for Developers
developer_usage_guide:
  description: "How to use these business rules in your code"
  
  basic_usage:
    - "Load business_rules_config.yaml in your application"
    - "Use mcp_compatible_queries templates directly"
    - "Apply definitive_logic_components for custom queries"
    - "Always include process_date_calculation for current data"
  
  example_implementations:
    simple_count: "Use mcp_compatible_queries.simple_active_member_count directly"
    breakdown_analysis: "Use mcp_compatible_queries.member_breakdown_by_account_type"
    financial_overview: "Use mcp_compatible_queries.financial_summary_active_products"
    custom_query: "Combine definitive_logic_components as needed"
  
  mcp_compatibility_notes:
    - "All templates are pure SELECT statements"
    - "No window functions or complex CTEs"
    - "No procedural code or temporary tables"
    - "Direct aggregation instead of complex subqueries where possible"
    - "Compatible with MCP SQL restrictions"

# Security and Access Control
access_control:
  
  sensitive_fields:
    description: "Fields requiring elevated permissions"
    fields:
      - table: "MEMBERREC"
        columns: ["SSN", "BIRTHDATE", "MOTHERSMAIDENNAME"]
        permission_level: "PII_READ"
      - table: "ACCOUNT"
        columns: ["RESTRICTACCESS", "FROZENMODE"]
        permission_level: "SECURITY_READ"
      - table: "LOAN"
        columns: ["CHARGEOFFDATE", "CHARGEOFFAMOUNT"]
        permission_level: "FINANCIAL_WRITE"
  
  audit_requirements:
    description: "Actions requiring audit logging"
    actions:
      - "UPDATE on SSN fields"
      - "DELETE on any financial record"
      - "UPDATE on CHARGEOFFDATE"
      - "ACCESS to deceased member records"

# Performance Optimization Indexes
recommended_indexes:
  - table: "ARCUSYM000.dbo.NAME"
    columns: ["PARENTACCOUNT", "MEMBERNUMBER", "TYPE"]
    type: "NONCLUSTERED"
  - table: "ARCUSYM000.dbo.ACCOUNT"
    columns: ["ACCOUNTNUMBER", "CLOSEDATE", "TYPE"]
    type: "CLUSTERED"
  - table: "ARCUSYM000.dbo.SAVINGS"
    columns: ["PARENTACCOUNT", "ID", "CLOSEDATE"]
    type: "NONCLUSTERED"
  - table: "ARCUSYM000.dbo.LOAN"
    columns: ["PARENTACCOUNT", "ID", "CLOSEDATE", "LASTPAYMENTDATE"]
    type: "NONCLUSTERED"
  - table: "TEMENOS.dbo.tblAccount"
    columns: ["AccountIdentifier", "DelinquentFlag", "ActiveFlag"]
    type: "NONCLUSTERED"

# ENHANCED RELATIONSHIP MAPPING CONFIGURATION
# ============================================
# Addresses critical relationship mismatches identified in database analysis

enhanced_table_relationships:
  primary_account_identifier: "ACCOUNT.ACCOUNTNUMBER"
  
  demographic_sources:
    primary:
      table: "NAME"
      join: "ACCOUNT.ACCOUNTNUMBER = NAME.PARENTACCOUNT"
      filter: "NAME.ORDINAL = 0 AND NAME.TYPE = 0"
      description: "Primary demographic source - use NAME table instead of MEMBERREC"
      fields_available: ["FIRST", "LAST", "BIRTHDATE", "ADDRESS", "PHONE", "SSN"]
      
    secondary:
      table: "MEMBERREC"
      join: "Complex - requires mapping table or substring match"
      note: "MEMBERID format (varchar 17) incompatible with ACCOUNTNUMBER (varchar 10)"
      issue: "Direct join not possible - use NAME table for demographics"
      memberid_format: "20081930000000007"
      accountnumber_format: "0000058219"
  
  product_relationships:
    savings:
      join: "ACCOUNT.ACCOUNTNUMBER = SAVINGS.PARENTACCOUNT"
      active_filter: "SAVINGS.CLOSEDATE IS NULL OR SAVINGS.CLOSEDATE = '1900-01-01'"
      process_date_filter: "SAVINGS.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
      
    loans:
      join: "ACCOUNT.ACCOUNTNUMBER = LOAN.PARENTACCOUNT"
      active_filter: "LOAN.CLOSEDATE IS NULL OR LOAN.CLOSEDATE = '1900-01-01'"
      chargeoff_filter: "LOAN.CHARGEOFFDATE IS NULL OR LOAN.CHARGEOFFDATE = '1900-01-01'"
      process_date_filter: "LOAN.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
      
    cards:
      join: "ACCOUNT.ACCOUNTNUMBER = CARD.PARENTACCOUNT"
      active_filter: "CARD.STATUS = 1"
      process_date_filter: "CARD.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
  
  transaction_relationships:
    savings_trans:
      join: "SAVINGS.ID = SAVINGSTRANSACTION.PARENTID"
      date_field: "EFFECTIVEDATE"
      amount_field: "BALANCECHANGE"
      missing_fields: ["ProcessDate"]
      available_date_fields: ["EFFECTIVEDATE", "POSTDATE", "ACTIVITYDATE"]
      
    loan_trans:
      join: "LOAN.ID = LOANTRANSACTION.PARENTID"
      date_field: "EFFECTIVEDATE"
      amount_field: "TRANAMOUNT"
      missing_fields: ["ProcessDate"]
      available_date_fields: ["EFFECTIVEDATE", "POSTDATE", "ACTIVITYDATE"]

# HELPER QUERY PATTERNS FOR COMMON OPERATIONS
# ==========================================
# Standardized patterns to avoid relationship mapping errors

helper_query_patterns:
  
  get_active_members_base_query:
    description: "Standard base query for active members"
    query: |
      SELECT DISTINCT a.ACCOUNTNUMBER
      FROM ACCOUNT a
      WHERE a.CLOSEDATE IS NULL OR a.CLOSEDATE = '1900-01-01'
      AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      AND a.TYPE = 0  -- General Membership

  get_demographics_query:
    description: "Get demographics from NAME table instead of MEMBERREC"
    query: |
      SELECT 
          n.PARENTACCOUNT as AccountNumber,
          n.BIRTHDATE,
          n.FIRST,
          n.LAST,
          n.SSN,
          DATEDIFF(YEAR, n.BIRTHDATE, GETDATE()) as Age
      FROM NAME n
      WHERE n.ORDINAL = 0  -- Primary name
      AND n.TYPE = 0  -- Primary type
      AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')

  get_member_product_summary:
    description: "Summary of products per member using correct relationships"
    query: |
      SELECT 
          a.ACCOUNTNUMBER,
          n.FIRST + ' ' + n.LAST as MemberName,
          COUNT(DISTINCT s.ID) as SavingsCount,
          COUNT(DISTINCT l.ID) as LoanCount,
          COUNT(DISTINCT c.CARDNUMBER) as CardCount,
          SUM(ISNULL(s.BALANCE, 0)) as TotalSavings,
          SUM(ISNULL(l.BALANCE, 0)) as TotalLoans
      FROM ACCOUNT a
      INNER JOIN NAME n ON a.ACCOUNTNUMBER = n.PARENTACCOUNT AND n.TYPE = 0 AND n.ORDINAL = 0
      LEFT JOIN SAVINGS s ON a.ACCOUNTNUMBER = s.PARENTACCOUNT 
          AND (s.CLOSEDATE IS NULL OR s.CLOSEDATE = '1900-01-01')
          AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      LEFT JOIN LOAN l ON a.ACCOUNTNUMBER = l.PARENTACCOUNT 
          AND (l.CLOSEDATE IS NULL OR l.CLOSEDATE = '1900-01-01')
          AND (l.CHARGEOFFDATE IS NULL OR l.CHARGEOFFDATE = '1900-01-01')
          AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      LEFT JOIN CARD c ON a.ACCOUNTNUMBER = c.PARENTACCOUNT 
          AND c.STATUS = 1
          AND c.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      WHERE (a.CLOSEDATE IS NULL OR a.CLOSEDATE = '1900-01-01')
      AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      GROUP BY a.ACCOUNTNUMBER, n.FIRST, n.LAST

# TRANSACTION ANALYSIS PATTERNS
# =============================
# Channel analysis and digital engagement tracking

transaction_analysis_patterns:
  
  channel_analysis_by_source_code:
    description: "Transaction channel analysis by source code"
    source_codes:
      'B': "Branch"
      'A': "ATM"
      'I': "Internet/Online"
      'M': "Mobile"
      'P': "Phone"
      'E': "Electronic/ACH"
      'T': "Teller"
    query: |
      SELECT 
          CASE st.SOURCECODE
              WHEN 'B' THEN 'Branch'
              WHEN 'A' THEN 'ATM'
              WHEN 'I' THEN 'Online Banking'
              WHEN 'M' THEN 'Mobile'
              WHEN 'P' THEN 'Phone'
              WHEN 'E' THEN 'Electronic'
              WHEN 'T' THEN 'Teller'
              ELSE 'Other'
          END as Channel,
          COUNT(*) as TransactionCount,
          COUNT(DISTINCT st.PARENTACCOUNT) as UniqueMembers,
          SUM(ABS(st.BALANCECHANGE)) as TotalAmount
      FROM SAVINGSTRANSACTION st
      WHERE st.EFFECTIVEDATE >= DATEADD(MONTH, -12, GETDATE())
      GROUP BY st.SOURCECODE
      ORDER BY TransactionCount DESC

  digital_engagement_indicators:
    description: "Identify digital engagement indicators"
    query: |
      SELECT 
          a.ACCOUNTNUMBER,
          -- Card Usage Indicator
          CASE WHEN EXISTS (
              SELECT 1 FROM CARD c 
              WHERE c.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND c.STATUS = 1
              AND c.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
          ) THEN 1 ELSE 0 END as HasActiveCard,
          
          -- Online/Mobile Transaction Indicator
          CASE WHEN EXISTS (
              SELECT 1 FROM SAVINGSTRANSACTION st 
              WHERE st.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND st.SOURCECODE IN ('I', 'M')
              AND st.EFFECTIVEDATE >= DATEADD(MONTH, -6, GETDATE())
          ) THEN 1 ELSE 0 END as HasDigitalTransactions,
          
          -- EFT Setup Indicator  
          CASE WHEN EXISTS (
              SELECT 1 FROM EFT e 
              WHERE e.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND e.STATUS = 'A'
          ) THEN 1 ELSE 0 END as HasActiveEFT,
          
          -- ATM Usage Indicator
          CASE WHEN EXISTS (
              SELECT 1 FROM SAVINGSTRANSACTION st 
              WHERE st.PARENTACCOUNT = a.ACCOUNTNUMBER 
              AND st.SOURCECODE = 'A'
              AND st.EFFECTIVEDATE >= DATEADD(MONTH, -3, GETDATE())
          ) THEN 1 ELSE 0 END as HasATMUsage
          
      FROM ACCOUNT a
      WHERE (a.CLOSEDATE IS NULL OR a.CLOSEDATE = '1900-01-01')
      AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')

# DIGITAL ENGAGEMENT SCORING COMPONENTS
# ====================================
# Multi-factor engagement scoring system

digital_engagement_scoring:
  
  engagement_score_calculation:
    description: "Multi-factor engagement scoring (0-100 scale)"
    components:
      product_diversity_score:
        weight: 25
        description: "Product diversity (25%)"
        calculation: "(COUNT(DISTINCT s.ID) + COUNT(DISTINCT l.ID)) * 12.5"
        
      balance_relationship_score:
        weight: 15
        description: "Balance relationship (15%)"
        tiers:
          - threshold: 100000
            score: 15
          - threshold: 50000
            score: 12
          - threshold: 25000
            score: 9
          - threshold: 10000
            score: 6
          - default: 3
            
      tenure_score:
        weight: 10
        description: "Member tenure (10%)"
        tiers:
          - years: 20
            score: 10
          - years: 10
            score: 8
          - years: 5
            score: 5
          - default: 2
            
      digital_adoption_score:
        weight: 20
        description: "Digital adoption (20%)"
        components:
          card_adoption: 10
          eft_enrollment: 10
          
      transaction_frequency_score:
        weight: 20
        description: "Transaction activity (20%)"
        calculation: "Based on transaction count in last 12 months"
        
      channel_diversity_score:
        weight: 10
        description: "Channel usage diversity (10%)"
        calculation: "Number of different channels used"
    
    complete_scoring_query: |
      SELECT 
          a.ACCOUNTNUMBER,
          n.FIRST + ' ' + n.LAST as MemberName,
          
          -- Product Diversity Score (25%)
          (COUNT(DISTINCT s.ID) + COUNT(DISTINCT l.ID)) * 12.5 as ProductScore,
          
          -- Balance Relationship Score (15%)
          CASE 
              WHEN SUM(ISNULL(s.BALANCE, 0)) > 100000 THEN 15
              WHEN SUM(ISNULL(s.BALANCE, 0)) > 50000 THEN 12
              WHEN SUM(ISNULL(s.BALANCE, 0)) > 25000 THEN 9
              WHEN SUM(ISNULL(s.BALANCE, 0)) > 10000 THEN 6
              ELSE 3
          END as BalanceScore,
          
          -- Tenure Score (10%)
          CASE 
              WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 20 THEN 10
              WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 10 THEN 8
              WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 5 THEN 5
              ELSE 2
          END as TenureScore,
          
          -- Digital Adoption Score (20%)
          (CASE WHEN card_data.CARDCOUNT > 0 THEN 10 ELSE 0 END +
           CASE WHEN eft_data.EFTCOUNT > 0 THEN 10 ELSE 0 END) as DigitalScore,
          
          -- Combined Engagement Score
          ((COUNT(DISTINCT s.ID) + COUNT(DISTINCT l.ID)) * 12.5 +
           CASE 
               WHEN SUM(ISNULL(s.BALANCE, 0)) > 100000 THEN 15
               WHEN SUM(ISNULL(s.BALANCE, 0)) > 50000 THEN 12
               WHEN SUM(ISNULL(s.BALANCE, 0)) > 25000 THEN 9
               WHEN SUM(ISNULL(s.BALANCE, 0)) > 10000 THEN 6
               ELSE 3
           END +
           CASE 
               WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 20 THEN 10
               WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 10 THEN 8
               WHEN DATEDIFF(YEAR, a.OPENDATE, GETDATE()) > 5 THEN 5
               ELSE 2
           END +
           (CASE WHEN card_data.CARDCOUNT > 0 THEN 10 ELSE 0 END +
            CASE WHEN eft_data.EFTCOUNT > 0 THEN 10 ELSE 0 END)) as TotalEngagementScore
            
      FROM ACCOUNT a
      INNER JOIN NAME n ON a.ACCOUNTNUMBER = n.PARENTACCOUNT AND n.TYPE = 0 AND n.ORDINAL = 0
      LEFT JOIN SAVINGS s ON a.ACCOUNTNUMBER = s.PARENTACCOUNT
          AND (s.CLOSEDATE IS NULL OR s.CLOSEDATE = '1900-01-01')
          AND s.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      LEFT JOIN LOAN l ON a.ACCOUNTNUMBER = l.PARENTACCOUNT
          AND (l.CLOSEDATE IS NULL OR l.CLOSEDATE = '1900-01-01')
          AND (l.CHARGEOFFDATE IS NULL OR l.CHARGEOFFDATE = '1900-01-01')
          AND l.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      LEFT JOIN (
          SELECT PARENTACCOUNT, COUNT(*) as CARDCOUNT
          FROM CARD 
          WHERE STATUS = 1
          AND ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
          GROUP BY PARENTACCOUNT
      ) card_data ON a.ACCOUNTNUMBER = card_data.PARENTACCOUNT
      LEFT JOIN (
          SELECT PARENTACCOUNT, COUNT(*) as EFTCOUNT
          FROM EFT 
          WHERE STATUS = 'A'
          GROUP BY PARENTACCOUNT
      ) eft_data ON a.ACCOUNTNUMBER = eft_data.PARENTACCOUNT
      WHERE (a.CLOSEDATE IS NULL OR a.CLOSEDATE = '1900-01-01')
      AND a.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      AND n.ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')
      GROUP BY a.ACCOUNTNUMBER, n.FIRST, n.LAST, a.OPENDATE, 
               card_data.CARDCOUNT, eft_data.EFTCOUNT

# QUERY OPTIMIZATION SETTINGS
# ==========================
# Performance and reliability improvements

query_optimization:
  max_transaction_days: 365      # Limit transaction queries to last year
  use_nolock: true              # For read-only queries
  chunk_size: 10000             # For large result sets
  timeout_seconds: 30           # Query timeout
  max_cte_depth: 3              # Reduced from 5 for MCP compatibility
  enable_parallel_execution: false  # Disable for MCP compatibility
  
# STANDARD FILTERS
# ===============
# Common filter patterns for consistency

standard_filters:
  active_account: "(CLOSEDATE IS NULL OR CLOSEDATE = '1900-01-01')"
  current_process_date: "ProcessDate = FORMAT(DATEADD(DAY, -1, GETDATE()), 'yyyyMMdd')"
  primary_name: "ORDINAL = 0 AND TYPE = 0"
  active_card_status: "STATUS = 1"
  active_loan: "((CLOSEDATE IS NULL OR CLOSEDATE = '1900-01-01') AND (CHARGEOFFDATE IS NULL OR CHARGEOFFDATE = '1900-01-01'))"
  active_savings: "(CLOSEDATE IS NULL OR CLOSEDATE = '1900-01-01')"
  valid_ssn: "SSN IS NOT NULL AND SSN <> ''"

# CHANNEL MAPPINGS
# ===============
# Transaction source code mappings

channel_codes:
  B: "Branch"
  A: "ATM"
  I: "Online Banking"
  M: "Mobile"
  P: "Phone"
  E: "Electronic/ACH"
  T: "Teller"
  O: "Other"

# TRANSACTION WEIGHTS
# ==================
# Channel priorities for engagement scoring

transaction_weights:
  mobile: 1.5        # Higher weight for digital channels
  online: 1.3
  electronic: 1.2
  atm: 1.0
  phone: 0.8
  branch: 0.6
  teller: 0.6
  other: 0.5

# IMMEDIATE FIXES IMPLEMENTATION
# =============================
# Critical corrections based on analysis

immediate_fixes:
  use_name_table_for_demographics:
    description: "Use NAME table instead of MEMBERREC for demographic queries"
    implementation: "All demographic queries should join via NAME.PARENTACCOUNT = ACCOUNT.ACCOUNTNUMBER"
    
  handle_missing_processdate_in_transactions:
    description: "Transaction tables don't have ProcessDate - use date ranges instead"
    solution: "Use EFFECTIVEDATE, POSTDATE, or ACTIVITYDATE with date range filters"
    example: "WHERE EFFECTIVEDATE >= DATEADD(MONTH, -12, GETDATE())"
    
  create_transaction_aggregates:
    description: "Pre-aggregate transaction data for performance"
    recommendation: "Create materialized views or summary tables for common transaction metrics"
    
  add_index_recommendations:
    description: "Database index recommendations for MCP queries"
    indexes:
      - "CREATE INDEX IX_NAME_PARENTACCOUNT_TYPE ON NAME (PARENTACCOUNT, TYPE, ORDINAL)"
      - "CREATE INDEX IX_SAVINGS_PARENTACCOUNT_CLOSEDATE ON SAVINGS (PARENTACCOUNT, CLOSEDATE, ProcessDate)"
      - "CREATE INDEX IX_LOAN_PARENTACCOUNT_STATUS ON LOAN (PARENTACCOUNT, CLOSEDATE, CHARGEOFFDATE, ProcessDate)"
      - "CREATE INDEX IX_SAVINGSTRANSACTION_EFFECTIVEDATE ON SAVINGSTRANSACTION (EFFECTIVEDATE, SOURCECODE)"
      
  implement_result_caching:
    description: "Cache frequently accessed data"
    cache_duration_minutes: 60
    cached_queries:
      - "Active member counts"
      - "Financial summaries" 
      - "Channel usage statistics"
      - "Engagement scores"

# TRANSACTION & DIGITAL ENGAGEMENT METRICS
# ========================================
# Available metrics despite relationship issues

available_metrics:
  channel_usage:
    source: "SOURCECODE in SAVINGSTRANSACTION and LOANTRANSACTION"
    metrics: ["Transaction count by channel", "Volume by channel", "Unique users by channel"]
    
  card_adoption:
    source: "CARD table STATUS field"
    metrics: ["Active card count", "Card adoption rate", "Card usage by type"]
    
  eft_enrollment:
    source: "EFT table"
    metrics: ["EFT setup rate", "Active EFT count", "EFT usage patterns"]
    
  online_banking_indicators:
    source: "CARDACCESS table and transaction source codes"
    metrics: ["Online banking adoption", "Digital transaction frequency"]
    
  mobile_adoption:
    source: "Transaction SOURCECODE = 'M'"
    metrics: ["Mobile transaction volume", "Mobile user count", "Mobile usage trends"]
    
  atm_usage:
    source: "Transaction SOURCECODE = 'A'"
    metrics: ["ATM transaction frequency", "ATM user patterns", "ATM location analysis"]

# VALIDATION RESULTS TRACKING
validation_status:
  last_validated: "2025-09-24"
  critical_fixes_applied:
    - "CLOSEDATE business rule corrected to NULL"
    - "CHARGEOFFDATE business rule corrected to NULL"
    - "Field names corrected (ID -> PARENTID, MBRSTATUS, MBRCREATEDATE)"
    - "Data type casting requirements added"
    - "ProcessDate filter requirements added"
    - "Magnitude validation rules implemented"
    - "Active member definition standardized"
    - "MCP-compatible query templates added"
    - "Column reference fixes applied (AccountNumber -> ACCOUNTNUMBER)"
    - "Simplified queries replacing complex specialized functions"
    - "Enhanced table relationship mappings implemented"  # NEW
    - "Helper query patterns for common operations added"  # NEW
    - "Transaction analysis patterns with channel mapping added"  # NEW
    - "Digital engagement scoring components implemented"  # NEW
    - "Query optimization settings configured"  # NEW
    - "Standard filters and channel codes defined"  # NEW
    - "Immediate fixes for MEMBERREC vs NAME table issues applied"  # NEW
  
  pending_validations:
    - "Transaction code mappings verification"
    - "Card status active values confirmation"
    - "Performance optimization testing"
    - "Fee capture process review"
    - "Digital engagement scoring validation"  # NEW
    - "Channel mapping accuracy verification"  # NEW
  
  known_issues_resolved:
    - "ProcessDate filter prevents historical aggregation"
    - "Member count now shows ~57.6K instead of 117K"
    - "Loan balance shows ~$351M instead of $53.9B"
    - "Active record queries now return correct counts"
    - "Profitability calculations use proper joins"
    - "Cross-database relationships properly mapped"
    - "MCP SQL restriction errors eliminated"
    - "Specialized function dependency removed"
    - "MEMBERREC vs NAME table relationship clarified"  # NEW
    - "Transaction table ProcessDate missing field handled"  # NEW
    - "Column name inconsistencies addressed"  # NEW
    - "Query performance timeout issues mitigated"  # NEW

# EFFECTIVENESS IMPROVEMENTS SUMMARY
# ==================================
# How these changes improve MCP effectiveness

effectiveness_improvements:
  accurate_relationships:
    - "Use NAME table for demographics instead of incompatible MEMBERREC joins"
    - "Proper table relationship mappings prevent join failures"
    - "Standardized helper patterns reduce query errors"
    
  performance_optimization:
    - "Query timeout settings prevent hanging queries"
    - "Transaction date range limits prevent performance issues"
    - "Index recommendations improve query speed"
    - "Result caching reduces redundant processing"
    
  digital_engagement_tracking:
    - "Channel analysis via SOURCECODE enables digital adoption metrics"
    - "Multi-factor engagement scoring provides member insights"
    - "Card, EFT, and online banking adoption tracking"
    - "Mobile and ATM usage pattern analysis"
    
  error_prevention:
    - "Standard filters prevent common query mistakes"
    - "Immediate fixes address known relationship issues"
    - "MCP-compatible patterns avoid SQL restriction errors"
    - "Data validation rules catch magnitude anomalies"
